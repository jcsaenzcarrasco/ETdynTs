\documentclass{elsarticle}
\biboptions{sort&compress}
\bibliographystyle{alpha}



\usepackage{amssymb}
%\setcounter{tocdepth}{3}
\usepackage{graphicx} 

% HASKELL SYNTAX HIGHLIGHTING - MUST BE LOADED BEFORE xcolor and listings IF THEY'RE ALSO BEING USED
\usepackage{mpshaskell}
\newcommand{\code}[1]{\haskell{#1}}
\newCodeWord{tree,list,original,reversed,x,xs,f,f',f'',y,ys,tour_x,tour_y,ex,ey,h,h',h'',e,e1,e2}
\newFunction{empty,singleton,member,reroot,splice,error,select,link,fromList',cut,path,guard,father}
\newSymbol{\insertL}{\lhd}
\newSymbol{\insertR}{\rhd}
% END OF HASKELL SYNTAX HIGHLIGHTING

% ADDED BY MIKE
\newcommand{\madd}[1]{\textcolor{Purple}{#1}}
\newcommand{\mdel}[1]{\textcolor{Yellow}{#1}}

\usepackage{xspace}
\newcommand{\MATHSF}[1]{\ensuremath{\mathsf{#1}}\xspace}
\newcommand{\link}{\MATHSF{link}}
\newcommand{\cut}{\MATHSF{cut}}
\renewcommand{\root}{\MATHSF{root}}
\newcommand{\reroot}{\MATHSF{reroot}}
\newcommand{\connected}{\MATHSF{connected}}
% END OF MIKE'S ADDITIONS


\usepackage{xcolor}

\usepackage{url}
%\urldef{\mailjm}\path|{jcsaenzcarrasco1, m.stannett}@sheffield.ac.uk|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\newcommand{\tcr} [1]{\textcolor{red}{#1}}
\newcommand{\tcb} [1]{\emph{\textcolor{blue}{#1}}}


\begin{document}
\title{Dynamic Trees through Euler Tours\\%
\large{A purely functional programming approach}}

\author{J.C.~Saenz-Carrasco\fnref{conacyt}\corref{cor1}}
\ead{jcsaenzcarrasco1@sheffield.ac.uk}

\author{M.~Stannett}
\ead{m.stannett@sheffield.ac.uk}

\address{Department of Computer Science,\\
Regent Court, 211 Portobello,\\
Sheffield S1 4DP, United Kingdom}

\cortext[cor1]{Corresponding author}
\fntext[conacyt]{Postgraduate research student, supported by the Consejo Nacional de Ciencia y Tecnolog\'{i}a, CONACYT (Mexican National Council for Science and Technology) under grant 411550, scholar 580617, CVU 214885.}

\begin{abstract}
We present purely-functional data structures for managing dynamic updates and queries, by combining the structure of Hinze and Paterson's finger tree with an efficient binary search tree to handle Euler tours as sequences: like its imperative counterpart, our proposal supports $O(\log n)$ amortised complexity per operation, where $n$ is the number of the vertices in the tree. While existing data structures mirror these time bounds, ours is arguably the first to provide all three of the basic dynamic tree operations (\link, \cut and \connected) within a single functional structure. To illustrate how the algorithms perform in practice we have implemented them in Haskell and conducted various benchmarking experiments. The data support our claims, while also pointing to remaining inefficiencies. We discuss these in detail and suggest possible ways forward.
\end{abstract}

\begin{keyword}
Dynamic tree algorithms \sep functional programming \sep persistent data structures \sep Haskell
\end{keyword}


\maketitle




\input{./Intro/Intro}


\tcr{---------- P O S I T I V E    C O M M E N T S ------------------}


\tcr{This paper introduces Euler Tour Finger Trees (ETFTs), a persistent, purely-functional tree and forest data structure that supports O(log n) complexity for all operations, including link and cut. It gives an implementation in Haskell.}

\tcr{At a high-level, the tree is represented as an Euler Tour (a list of vertex pairs describing a path through the tree), which in turn is represented by a finger tree, thereby allowing O(log n) concatenation and splitting. That allows manipulating Euler tours efficiently, and building interesting tree operations easily.}

\tcr{Most of the implementation in this paper thus builds on existing implementations of finger trees and sets. Yet the combination seems novel, and the complexity bounds of the ETFT operations follow almost trivially, which is nice.
The paper presents a functional data structure for maintaining a dynamic forest under link and cut operations. It realizes this in O(log n) time complexity per operation (amortized), using an Euler tour tree representation implemented using a combination of finger trees and sets. }

\tcr{The paper first recalls dynamic trees and their operations, and then monoids, sets implemented with balanced search trees, Euler-tour trees and finger trees. It then gives (graphical) examples of how the sets and finger trees fit together to realize dynamic trees, it recalls graphically the root, reroot, split, concatenation, and view operations of finger trees, and then walks through the implementation of root, reroot, connected, link, and cut.
Finally the paper contains experiments illustrating that the implementation meets the claimed complexity bounds and discusses related and future work.
This is an interesting piece of work.}
%\end{comment}


\input{./Prelim/Prelim}

%\input{./Example/Example}

\input{./TechDes/TechDes} 

\input{./Eval/Eval} 

\input{./RelWrk/RelWrk} 

\input{./Concl/Concl} 

\bibliography{./Refs/refs}

%\begin{thebibliography}{4}
%\input{./Refs/refs.bib}
%\end{thebibliography} 

\end{document}
