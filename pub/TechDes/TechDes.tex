\section{dynTsET Design}
\label{sec:TechDes}  

\tcr{My main criticism of the paper is the presentation. While I appreciate the use of diagrams in the first half of the paper, high-level explanations are missing later. The paper does not do a very good job providing an intuition for how the data structure works. For example, I was struggling understanding the role of the monoidal set. The paper also explains too little of the background regarding used existing data structures and their realisation in Haskell libraries. For example, the interface to the finger tree ADT and the Measured type class. In general, most of the explanations are closely tight to the code but donâ€™t give a high-level picture of what individual operations do in terms of the Euler tour. Given that there is plenty of space left in the paper, this could be improved in the final version.}

\tcr{This reviewer can't help but think that there seems to be a lot of redundancy in the proposed data structure, as the Euler tour node pairs are present in both the sets and in the finger trees.}


In this section, we present the data types and the operations to manage dynamic trees through Euler-tour trees. Firstly, we describe how to convert any-degree tree into a Euler-tour tree. Secondly, assuming we are provided with Euler-tour trees, we stored them within the leaves of a finger tree. Also, we detail the functions for linking and cutting trees when performed in isolation. Finally, we incorporate the Euler-tour trees into the context of a forest. At this point, we describe the three operations regarded to dynamic trees: \connected, \link and \cut for trees (nodes and edges) within a forest. At any time, the number of nodes is fixed and every node is uniquely identified. Full source code is located at \url{https://github.com/jcsaenzcarrasco/ETdynTs}.


\subsection{From $k$-degree tree to Euler-tour tree}

In Haskell, any-degree tree is also known as multiway tree or rose tree. Actually, there is a library that defines such trees, \code{Data.Tree}, in the Haskell community's central package archive (Hackage).

\begin{lstlisting}
data Tree a = Node {
        rootLabel :: a,         
        subForest :: Forest a   
    }
\end{lstlisting}

So, a tree is a node of type \code{a} (i.e. its root) altogether with a list (possibly empty) of subtrees, seen as forest of type \code{Forest a}. Analogous to multiway trees, our trees (finger trees holding Euler-tours) can not be empty. 

Firstly, we turn a tree into a list of nodes, by attaching (mapping) the prefix and suffix of current node to inner subtrees. We later feed this list into a finger tree. 

\begin{lstlisting}[mathescape] 
rt2et :: (Eq a) $\Rightarrow$ Tree a $\to$ [(a,a)] 
rt2et (Node x ts) = case ts of
  [] $\to$ [(x,x)]
  _  $\to$ root ++ concat ( map ($\lambda$t $\to$ pref t ++ rt2et t ++ suff t) ts )   
    where
     pref v = [(x,rootLabel v)]
     suff v = [(rootLabel v,x)]
     root   = [(x,x)] 
\end{lstlisting} 

Since \code{concat} and \texttt{++} take $O(n)$ where $n$ is the size of the input tree, \code{rt2et} takes $O(n)$. \tcr{Should we need to prove this ???}

The corresponding forest transformation to list of pairs is simply the application of \code{rt2et} to every element in the tree list. Because it requires a single traversal, \code{rt2et} requires $O(n)$ time, where $n$ is the number of elements in the forest.

\begin{lstlisting}[mathescape] 
rf2et :: (Eq a) $\Rightarrow$ Forest a $\to$ [[(a,a)]]
rf2et []          = []
rf2et [Node x []] = [[(x,x)]]  
rf2et (t:ts)      = (rt2et t) : rf2et ts
\end{lstlisting}

Once a tree $t$ of any degree is turned into an Euler tour $et$, we are able to manage $et$ as a sequence. 


\subsection{Euler-tour tree as finger trees of pairs}

Since finger trees work efficiently on sequences, according to \cite{FTs}, we tailored the finger tree in order to support \link, \cut and \connected operations over unrooted trees following the procedures for modifying encodings (i.e. any-degree trees to Euler-tours) by Henzinger and King in \cite{Rand-DynGs-Algos}.

Recall from Figure~\ref{fig:FTdatatype}, the finger tree \code{data FingerTree v a}, has two polymorphic types, the first one (\code{v}) is the type of the monoidal annotation and the second (\code{a}) the type of the values stored at the leaves, which in our case is the sequence type. We have mentioned in the previous section that edges and nodes can be represented as pairs, therefore our values type is \code{(a,a)} for any type \code{a}. In this manner, a pair $(u,v)$ (atomic element in the sequence) represents a node, when $u = v$, and an edge when $u \neq v$. From here, every element in the sequence  can be located.

In the next sections, for practical reasons, we define our pairs of type \code(Int,Int). For the internal finger trees nodes (monoidal annotations), where searching take place, we define \code{Data.Set (a,a)} as our type. By doing so, we are able to take advantage from some set-like operations such as membership-test, insertion and union. 

We define the set-insertion operation every time a pair (either edge or node) is added to an Euler-tour tree (i.e. finger tree). In Haskell, we can see this as
\begin{lstlisting}[mathescape]
import Data.FingerTree
import qualified Data.Set as S

type TreeEF   a = FingerTree (S.Set (a,a)) (a,a)

instance (Ord a) $\Rightarrow$ Measured (S.Set (a,a)) (a,a) where 
   measure (x,y) = S.insert (x,y) S.empty 
\end{lstlisting} 

We shall see in Section~\ref{DoNotKnowYet} that \code{S.Set} can be easily replaced by another set alike data structure as long as this provides membership-testing, insertion, empty-set, set-union and search operations. Also in Section~\ref{sec:Eval} we shall analyse the differences in performance when the monoidal type is changed.

The set-union is already defined in \code{Data.Set} at its monoidal binary operation, therefore there is no need to define this in our proposal.


\subsection{rooting and rerooting a tree}
We shall see later in the definition of \link, \code{link} \cut, and \connected, that functions \root and \reroot are essential. We mentioned earlier that dynamic trees is about managing unrooted trees. By \root we refer to the entry point of any Euler-tour, which always starts in the form $(v,v)$ since it represents a node. By \emph{unrooted} tree we refer to the fact that any node in the tree can be its \root.

Since any-size Euler-tour is represented from now on by a finger tree, we define our initial operation by calling the leftist element as the \root of it, through the function \code{viewl}
\begin{lstlisting}[mathescape] 
root :: Ord a $\Rightarrow$ TreeEF a $\to$ Maybe a  
root tree = case viewl tree of
  EmptyL   $\to$ Nothing
  x :< _   $\to$ Just ( fst x )
\end{lstlisting}

We return the first element in the pair $(v,v)$ since any $v$ represents the node-root. Time complexity of \root is $O(1)$ since \code{viewl} performs $O(1)$ in the finger tree and we simply pattern match over its results.

Then, for \code{reroot}ing a tree we follow partially the second procedure by Henzinger and King in \cite{Rand-DynGs-Algos}, which states:
\begin{displayquote}
\emph{To change the root of \textit{T} from $r$ to $s$}: Let $o_s$ denote any occurrence of $s$. Splice out the first part of the sequence ending with the occurrence before $o_s$, remove its first occurrence ($o_r$), and tack the first part on to the end of the sequence, which now begins with $o_s$. Add a new occurrence $o_s$ to the end.
\end{displayquote}

So, instead of looking for $r$ (old root) occurrences, we focus only in the new root($s$). We splice out the first and second occurrences of node $s$ by simply searching for it as $(s,s)$ in the finger tree. Then, simply glue all the parts in order, that is, the new root first (leftist) followed by the second and first occurrences of $s$. This is denoted in the following snippet.

\begin{lstlisting}[mathescape]
reroot :: Ord a $\Rightarrow$ TreeEF a $\to$ a $\to$ TreeEF a 
reroot tree node = case (FT.search pred tree) of
   Position left _ right $\to$ rootTree $\lhd$ (right $\bowtie$ left)
   _                     $\to$ tree
 where rootTree      = (node,node)
       pred before _ = (S.member rootTree) before
\end{lstlisting} 

\tcr{PERFORMANCE of REROOT }\tcb{Operators $\lhd$, $\bowtie$ and \code{FT.search} take $O(\log n)$ amortised on finger trees. Since we are applying them only once, our \code{reroot} function also takes $O(\log n)$}. In case \code{reroot} is asked altogether with a node not in the tree, it simply returns the original \code{tree}.

The following two functions, \code{linkTree} and \code{cutTree} are regarded to trees off a forest. Again, following Henzinger and King, first procedure in \cite{Rand-DynGs-Algos}:
\begin{displayquote}
\emph{To delete edge \{$a$,$b$\} from $T$:} Let $T_1$ and $T_2$ be the two trees that result, where $a \in$ $T_1$ and $b \in$ $T_2$. Let $o_{a_1}$, $o_{b_1}$, $o_{b_2}$ represent the occurrences encountered in the two traversals of \{$a,b$\}. If $o_{a_1} < o_{b_1}$ and $o_{b_1} < o_{b_2}$, then $o_{a_1} < o_{b_1} < o_{b_2} < o_{a_2}$. Thus, ET($T_2$) is given by the interval of ET($T$) $o_{b_1}$, \ldots, $o_{b_2}$ and ET($T_1$) is given by splicing out of ET($T$) the sequence $o_{b_1}$, \ldots, $o_{a_2}$. 
\end{displayquote} 

Deleting an edge means \emph{cut}ting a tree through such edge. The following snippet shows the \code{cutTree} operation analogous to the above procedure :
\begin{lstlisting}[mathescape]
cutTree :: Ord a $\Rightarrow$ a $\to$ a $\to$ TreeEF a $\to$ Maybe (TreeEF a,TreeEF a) 
cutTree u v tree = case FT.search predUV tree of
 Position left _ right $\to$
   case (FT.search predVU left ) of
      Position leftL _ rightL $\to$  
        Just (rightL, leftL $\bowtie$ right)
      _                $\to$                    
        case (FT.search predVU right) of
          Position leftR _ rightR $\to$
            Just (leftR, left $\bowtie$ rightR)
          _ $\to$ Nothing 
 _  $\to$ Nothing  
 where
   predUV before _ = (S.member (u,v)) before 
   predVU before _ = (S.member (v,u)) before 
\end{lstlisting}

The snippet quite follows the procedure. The pairs $(u,v)$ and $(v,u)$ are left out the resulting sequences in the wildcards in lines 3, 5 and 9. Since we search $(u,v)$ first, there are only two possibilities for $(v,u)$ to be part of. If it is on the left we build up $T_1$ from \code{rightL}, and $T_2$ from \code{leftL} and \code{right}. Otherwise $T_1$ is built from \code{leftR} and $T_2$ from \code{left} and \code{rightR}.

\tcr{PERFORMANCE of CUT }\tcb{Operator $\bowtie$ and function \code{FT.search} take $O(\log n)$ amortised on finger trees. Since we are applying them twice, our \code{cut} function also takes $O(\log n)$}. In case \code{cut} is called with with nodes belonging different components or the edge in matters in not found, then \code{cut} returns \code{Nothing}, which will be captured as failure in \cut within a forest operation.


